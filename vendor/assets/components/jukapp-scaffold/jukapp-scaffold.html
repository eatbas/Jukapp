<link rel="import" href="../core-toolbar/core-toolbar.html">
<link rel="import" href="../core-drawer-panel/core-drawer-panel.html">
<link rel="import" href="../core-header-panel/core-header-panel.html">
<link rel="import" href="../core-icon-button/core-icon-button.html">
<link rel="import" href="../jukapp-bottom-sheet/jukapp-bottom-sheet.html">
<link rel="import" href="../paper-input/paper-input.html">

<polymer-element name="jukapp-scaffold" attributes="queue isOwner">
  <template>

  <style>

    :host {
      display: block;
    }

    [drawer] {
      background-color: #fff;
      box-shadow: 1px 0 1px rgba(0, 0, 0, 0.1);
    }

    [main] {
      height: 100%;
      background-color: #eee;
    }

    core-toolbar {
      background-color: #526E9C;
      color: #fff;
    }

    #drawerPanel:not([narrow]) #menuButton {
      display: none;
    }

    .content {
      margin-bottom: 73px;
    }
    /* Paper input decorator */
    paper-input-decorator /deep/ .label-text,
    paper-input-decorator /deep/ .input-body {
      /* inline label,  floating label, error message and error icon color when the input is unfocused */
      opacity: 0.87;
      color: black;
    }
    paper-input-decorator /deep/ ::-webkit-input-placeholder {
      /* platform specific rules for placeholder text */
      opacity: 0.54;
      color: white;
    }
    paper-input-decorator /deep/ ::-moz-placeholder {
      opacity: 0.54;
      color: white;
    }
    paper-input-decorator /deep/ :-ms-input-placeholder {
      opacity: 0.54;
      color: white;
    }

    paper-input-decorator /deep/ .unfocused-underline {
      /* line color when the input is unfocused */
      background-color: black;
    }

    paper-input-decorator[focused] /deep/ .floated-label .label-text {
      /* floating label color when the input is focused */
      opacity: 0.87;
      color: black;
    }

    paper-input-decorator /deep/ .focused-underline {
      /* line color when the input is focused */
      background-color: black;
    }
  </style>

  <core-drawer-panel id="drawerPanel" narrow="{{narrow}}" drawerWidth="{{drawerWidth}}" responsiveWidth="{{responsiveWidth}}" disableSwipe="{{disableSwipe}}">

    <div vertical layout drawer>

      <content select="[navigation], nav"></content>

    </div>

    <core-header-panel id="headerPanel" main mode="{{mode}}">

      <paper-shadow>
        <core-toolbar class="medium-tall" raised>
          <paper-icon-button id="menuButton" icon="{{searchMode ? 'arrow-back' : 'menu'}}" on-tap="{{menuClicked}}"></paper-icon-button>
          <div flex style="{{searchMode ? 'display: none;' : ''}}">
            <content select="[tool]"></content>
          </div>
          <div flex style="{{searchMode ? '' : 'display: none;'}}">
            <paper-input-decorator id="searchInputDecorator" label="Search">
              <input id="searchInput" is="core-input" on-keydown="{{keydownHandler}}">
            </paper-input-decorator>
          </div>
          <paper-icon-button id="searchButton" icon="search" on-tap="{{searchClicked}}"></paper-icon-button>
          <div class="middle fit">
            <content select=".paper-tabs"></content>
          </div>
        </core-toolbar>
      </paper-shadow>

      <div class="content">
        <content select="*"></content>
      </div>

      <jukapp-bottom-sheet hasDeleteButton={{isOwner}} drawerWidth="{{drawerWidth}}" narrow={{narrow}} queue={{queue}}></jukapp-bottom-sheet>
    </core-header-panel>

  </core-drawer-panel>

</template>
<script>

  Polymer('jukapp-scaffold', {

    /**
    * Fired when the main content has been scrolled.  `event.detail.target` returns
    * the scrollable element which you can use to access scroll info such as
    * `scrollTop`.
    *
    *     <jukapp-scaffold on-scroll="{{scrollHandler}}">
    *       ...
    *     </jukapp-scaffold>
    *
    *
    *     scrollHandler: function(event) {
    *       var scroller = event.detail.target;
    *       console.log(scroller.scrollTop);
    *     }
    *
    * @event scroll
    */

    publish: {

      /**
      * Width of the drawer panel.
      *
      * @attribute drawerWidth
      * @type string
      * @default '256px'
      */
      drawerWidth: '256px',

      /**
      * When the browser window size is smaller than the `responsiveWidth`,
      * `core-drawer-panel` changes to a narrow layout. In narrow layout,
      * the drawer will be stacked on top of the main panel.
      *
      * @attribute responsiveWidth
      * @type string
      * @default '600px'
      */
      responsiveWidth: '600px',

      /**
      * If true, swipe to open/close the drawer is disabled.
      *
      * @attribute disableSwipe
      * @type boolean
      * @default false
      */
      disableSwipe: false,

      /**
      * Used to control the header and scrolling behaviour of `core-header-panel`
      *
      * @attribute mode
      * @type string
      * @default 'seamed'
      */
      mode: {value: 'seamed', reflect: true},
      queue: [],
      searchMode: false
    },

    ready: function() {
      this._scrollHandler = this.scroll.bind(this);
      this.$.headerPanel.addEventListener('scroll', this._scrollHandler);
    },

    detached: function() {
      this.$.headerPanel.removeEventListener('scroll', this._scrollHandler);
    },

    searchClicked: function() {
      if(this.searchMode) {
        this.fire("search", {query: this.$.searchInput.value});
        this.$.searchInput.value = "";
        this.searchMode = false;
      } else {
        this.searchMode = true;
      }
    },

    keydownHandler: function(e) {
      switch (e.keyCode) {
        case 13: // enter
          this.searchClicked();
          break;
      }
    },

    menuClicked: function() {
      if(this.searchMode) {
        this.searchMode = false;
      } else {
        this.togglePanel();
      }
    },

    searchModeChanged: function() {
      if(this.searchMode) {
        setTimeout(function() {
          this.$.searchInput.focus();
        }.bind(this), 50);
        $(this.$.menuButton).show();
      } else {
        $(this.$.menuButton).attr("style", "");
      }
    },

    /**
    * Toggle the drawer panel
    * @method togglePanel
    */
    togglePanel: function() {
      this.$.drawerPanel.togglePanel();
    },

    /**
    * Open the drawer panel
    * @method openDrawer
    */
    openDrawer: function() {
      this.$.drawerPanel.openDrawer();
    },

    /**
    * Close the drawer panel
    * @method closeDrawer
    */
    closeDrawer: function() {
      this.$.drawerPanel.closeDrawer();
    },

    /**
    * Returns the scrollable element on the main area.
    *
    * @property scroller
    * @type Object
    */
    get scroller() {
      return this.$.headerPanel.scroller;
    },

    scroll: function(e) {
      this.fire('scroll', {target: e.detail.target}, this, false);
    },

  });

</script>
</polymer-element>
